---
title: "Time to Restore data - 2025"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Erin Zylstra"
execute: 
  error: false
  warning: false
  message: false
format: 
  html:
    code-fold: true
    fig-cap-location: top
    page-layout: full
editor: visual
---

```{r}
#| echo: false
#| output: false

require(rnpn)
require(dplyr)
require(lubridate)
require(stringr)
require(tidyr)
library(terra)
library(tidyterra)

# Logical indicating whether to re-download data
update_data <- FALSE

# Create custom rounding function ---------------------------------------------#

# This is the same as plyr::round_any(), but loading the plyr package often 
# causes conflicts with function names when dplyr is loaded

round_any <- function(x, accuracy) {
  round(x / accuracy) * accuracy
}
```

### Identifying priority species

Used list of priority species based on: TimeToRestore_AllPrioritySpecies_2024 [google sheet](https://docs.google.com/spreadsheets/d/1NnuTGT7OZuA9WGD0cg29d3INNV0n_x9C/edit?gid=794771851#gid=794771851) (extracted on 2 April 2025). Made a few edits in there to correct the spelling of one genus (Vernonia) and one species (cespitosa). Updated scientific and common names based on ITIS for mistflower (Conoclinium), basket-flower (Centaurea), and Lantana. Will use the common name listed in ITIS/NPN data base for these species in this document. Finally, there were a couple species that were listed under two different common anmes in the google sheet (*Sambucus nigra, Passiflora incarnata*); using the common name listed in NPN database in this document.

```{r priority-spp}
#| echo: false
#| output: false
#| code-fold: true

# Load list of priority species
spp_list <- read.csv("data/ttr-priorityspecies-20250402.csv", 
                     na.strings = c(NA, ""))
spp_list <- spp_list %>%
  mutate(across(c(common_name, scientific_name), str_trim)) %>%
  # Edit spelling of one genus (Vernonia) and one species (cespitosa)
  # Update species based on ITIS for mistflower (Conoclinium), 
  # basket-flower (Centaurea), and Lantana
  mutate(scientific_name = case_when(
    scientific_name == "Oenothera caespitosa" ~ "Oenothera cespitosa",
    scientific_name == "Veronia gigantea" ~ "Vernonia gigantea",
    scientific_name == "Conoclinium greggii" ~ "Conoclinium dissectum",
    scientific_name == "Centaurea americana" ~ "Plectocephalus americanus",
    scientific_name == "Lantana urticoides" ~ "Lantana horrida", 
    .default = scientific_name
  )) %>%
  rename(ttr_common_name = common_name)

# Load information about NN species
nn_spp <- npn_species() %>% data.frame()
nn_spp <- nn_spp %>%
  filter(kingdom == "Plantae") %>%
  select(species_id, common_name, genus, species, functional_type) %>%
  mutate(scientific_name = paste(genus, species))

# Find NN info based on scientific name of priority species (inconsistent 
# capitalization in priority list and a duplicate in NN database [Canada goldenrod])
spp_list <- spp_list %>%
  left_join(nn_spp, by = "scientific_name")
# Check that all priority species have a match in NN database
  # filter(spp_list, is.na(species_id))
# Are there any duplicates? Yes
  count(spp_list, species_id) %>% filter(n > 1)
  filter(spp_list, species_id == 90) 
  # In priority list, Sambucus nigra listed as both black and common elderberry
  filter(spp_list, species_id == 182) 
  # In priority list, Passiflora incarnata listed as both purple passionflower and Maypop

# Remove entries for TTR priority species whose common name doesn't match NPN
spp_list <- spp_list %>%
  filter(!ttr_common_name %in% c("Maypop", "Common elderberry"))
# 53 species
```

This leaves us with `r nrow(spp_list)` priority species.

### Downloading status-intensity data

Used rnpn to download status and intensity data for priority species in Louisianna, New Mexico, Oklahoma, and Texas in 2023-2025. Downloaded observations of 4 phenophases: flowers and flower buds (flower), open flowers, fruit, and ripe fruit. Since leaves on milkweed plants may be important for monarch eggs and catepillars, we also downloaded observations of the leaves phenophase for the `r length(str_detect(spp_list$common_name, "milkweed"))` species of milkweed on the priority list.

```{r download}
#| echo: false
#| output: false
#| code-fold: true

# First, check that all species have these 4 phenophases
phenophases_byspp <- npn_phenophases_by_species(
  species_ids = c(spp_list$species_id),
  date = "2025-01-01"
) %>% data.frame()
phenophases_byspp %>%
  group_by(species_id, species_name) %>%
  summarize(p500 = ifelse(500 %in% phenophase_id, 1, 0),
            p501 = ifelse(501 %in% phenophase_id, 1, 0),
            p516 = ifelse(516 %in% phenophase_id, 1, 0),
            p390 = ifelse(390 %in% phenophase_id, 1, 0),
            .groups = "keep") %>%
  rowwise() %>%
  filter(sum(c_across(p500:p390)) < 4)
# All species use these 4 phenophases

# What phenophases do the milkweeds use?
milkweed_phps <- phenophases_byspp %>%
  filter(str_detect(species_name, "milkweed")) %>%
  select(species_id, species_name, pheno_class_id, phenophase_id, phenophase_name) %>%
  arrange(species_name, pheno_class_id, phenophase_id)
# Since leaves may be important for monarch eggs and catepillars, we may also 
# want to include:
# 488 = Leaves (for milkweeds only)

# Download and format (or load existing) NPN data for priority plant species --#
  
# Observations in 4 states (LA, NM, OK, TX)
# Focus on 2025 data, but also download 2024 data (for fruits and/or comparison)

phenophases <- c(500, 501, 516, 390)
states4 <- c("LA", "NM", "OK", "TX")
  # Minor note: we could be missing observations in the four states if we use
  # the states argument in the download function because sometimes the state 
  # field is missing or incorrect. Won't worry about that here, but would be 
  # better in the long run to check state values based on lat/lons

data_filename <- "data/ttr-data-20232025.csv"

if (!file.exists(data_filename) | update_data == TRUE) {
  
  # Download flowering, fruiting data for 2024-2025 (including 2023 so that 
  # we can calculated individual phenometrics for 2024, if needed)
  status_dl <- npn_download_status_data(
    request_source = "erinz",
    years = 2023:2025,
    species_ids = spp_list$species_id,
    phenophase_ids= phenophases,
    states = states4,
    additional_fields = c("observedby_person_id",
                          "partner_group",
                          "site_name", 
                          "species_functional_type"))
  status_dl <- data.frame(status_dl)
  
  # Download leafing data for milkweeds in 2024-2025
  milkweeds <- spp_list %>%
    filter(str_detect(common_name, "milkweed")) %>%
    pull(species_id)
  status_mwleaf_dl <- npn_download_status_data(
    request_source = "erinz",
    years = 2023:2025,
    species_ids = milkweeds,
    phenophase_ids= 488,
    states = states4,
    additional_fields = c("observedby_person_id",
                          "partner_group",
                          "site_name", 
                          "species_functional_type"))
  status_mwleaf_dl <- data.frame(status_mwleaf_dl)
  
  # Combine everything and format
  status_df <- rbind(status_dl, status_mwleaf_dl) %>%
    mutate(obsdate = ymd(observation_date),
           yr = year(obsdate),
           php = case_when(
             phenophase_id == 500 ~ "flower",
             phenophase_id == 501 ~ "open flower",
             phenophase_id == 516 ~ "fruit",
             phenophase_id == 390 ~ "ripe fruit",
             phenophase_id == 488 ~ "leaves")) %>%
    select(-c(update_datetime, elevation_in_meters, genus, species, kingdom,
              phenophase_description, abundance_value, observation_date)) %>%
    rename(person_id = observedby_person_id,
           func_type = species_functional_type,
           lat = latitude,
           lon = longitude)
  
  # Write to file
  write.csv(status_df, data_filename, row.names = FALSE)
  # Remove objects
  rm(status_df, status_dl, status_mwleaf_dl)
}

status <- read.csv(data_filename)
```

Then, we appended information about intensity categories, and calculated approximate midpoint values for each intensity category in the status-intensity dataset.

```{r intensities}
#| echo: false
#| code-fold: true
#| output: false

# Download information about intensity categories
ic <- npn_abundance_categories() %>% data.frame()
ic <- ic %>%
  rename(intensity_category_id = category_id, 
         intensity_value_id = value_id,
         intensity_name = category_name,
         intensity_value = value_name) %>%
  select(-c(category_description, value_description))

# Extract just those categories that appear in status data and format:
ic_subset <- ic %>%
  filter(intensity_category_id %in% unique(status$intensity_category_id)) %>%
  mutate(value1 = NA,
         value2 = NA,
         intensity_type = case_when(
           str_detect(intensity_value, "%") ~ "percent",
           str_detect(intensity_value, "[0-9]") ~ "number",
           .default = "qualitative"
         ))
val12 <- which(colnames(ic_subset) %in% c("value1", "value2"))
for (i in 1:nrow(ic_subset)) {
  if (str_detect(ic_subset$intensity_value[i], " to ")) {
    ic_subset[i, val12] <- str_split_fixed(ic_subset$intensity_value[i], " to ", 2)
    ic_subset[i, val12] <- as.numeric(str_remove(ic_subset[i, val12], ","))
  } else if (str_detect(ic_subset$intensity_value[i], "-")) {
    ic_subset[i, val12] <- str_split_fixed(ic_subset$intensity_value[i], "-", 2)
    ic_subset[i, val12[2]] <- str_remove(ic_subset[i, val12[2]], "%")
  } else if (str_detect(ic_subset$intensity_value[i], "% or more")) {
    ic_subset[i, val12] <- str_remove(ic_subset$intensity_value[i], "% or more")
  } else if (str_detect(ic_subset$intensity_value[i], "Less than ")) {
    ic_subset[i, val12[1]] <- 0
    ic_subset[i, val12[2]] <- str_remove(ic_subset$intensity_value[i], "Less than ")
    ic_subset[i, val12[2]] <- str_remove(ic_subset[i, val12[2]], "%")
  } else if (str_detect(ic_subset$intensity_value[i], "More than ")) {
    ic_subset[i, val12] <- str_remove(ic_subset$intensity_value[i], "More than ")
    ic_subset[i, val12[1]] <- as.numeric(str_remove(ic_subset[i, val12[1]], ",")) + 1
    ic_subset[i, val12[2]] <- as.numeric(str_remove(ic_subset[i, val12[2]], ",")) + 1
  }
}
ic_subset <- ic_subset %>%
  mutate_at(c("value1", "value2"), as.numeric)

# Assigning a middle-ish value for each range (keeping it to nice numbers like 
# 5, 50, 500, and 5000)
ic_subset <- ic_subset %>%
  mutate(mag = nchar(value1) - 1) %>%
  mutate(value = case_when(
    value1 == value2 ~ round(value1),
    intensity_type == "number" & value1 == 0 ~ 1,
    intensity_type == "number" & value1 != 0 ~ 
      round_any(rowMeans(across(value1:value2)), 5 * (10 ^ mag)),
    intensity_type == "percent" ~ round(rowMeans(across(value1:value2))),
    .default = NA
  )) %>%
  select(-c(mag, value1, value2))

ic_append <- ic_subset %>%
  select(intensity_category_id, intensity_name, intensity_value, value) %>%
  rename(intensity_cat = intensity_value, 
         intensity = value)

status <- status %>%
  left_join(ic_append, 
            by = c("intensity_category_id", 
                   "intensity_value" = "intensity_cat")) %>%
  select(-intensity_category_id)
```

### Identified duplicate observations

Looked at all status-intensity data and identified instances where an observer submitted the same data twice in one day (same plant, phenophase status, and intensity value).

```{r duplicates}
#| echo: false
#| code-fold: true
#| output: false

# Duplicate by same observer: all years (2023-2025)
dups <- status %>%
  group_by(person_id, individual_id, obsdate, yr, phenophase_id, 
           phenophase_status, intensity) %>%
  summarize(nobs = n(), .groups = "keep") %>%
  data.frame() %>%
  count(nobs)
# dups
n_dups <- sum(dups$n * (dups$nobs - 1))
n_dups_percent <- round(n_dups / nrow(status) * 100, 2) 

# Duplicate by same observer: 2025 only
dups25 <- status %>%
  filter(yr == 2025) %>%
  group_by(person_id, individual_id, obsdate, yr, phenophase_id, 
           phenophase_status, intensity) %>%
  summarize(nobs = n(), .groups = "keep") %>%
  data.frame() %>%
  count(nobs)
# dups25
n_dups25 <- sum(dups25$n * (dups25$nobs - 1))
n_dups25_percent <- round(n_dups25 / nrow(status[status$yr == 2025,]) * 100, 2)

# Removing duplicates (will cause problems later)
status <- status %>% distinct(across(-observation_id))

# Duplicate by multiple observers: all years
dups2 <- status %>%
  group_by(individual_id, obsdate, phenophase_id, phenophase_status,
           intensity) %>%
  summarize(nobs = n(), .groups = "keep") %>%
  data.frame() %>%
  count(nobs)
dups2
n_dups2 <- sum(dups2$n * (dups2$nobs - 1))
n_dups2_percent <- round(n_dups2 / nrow(status) * 100, 2)
```

There were a total of `r n_dups` observations (`r n_dups_percent`%) across all years that were duplicates, and a total of `r n_dups25` observations (`r n_dups25_percent`%) in 2025 that were duplicates. Duplicates submitted by the same observer were removed from the dataset. There were also instances where multiple observers submitted the same information on the same day (`r n_dups2_percent`% of 2023-2025 observations), though this is less likely to reflect a data entry error than duplicate observations by the same observer on the same day so no observations were removed at this point.

### Identifying issues related to reported intensity values

```{r intensity-probs}
#| echo: false
#| code-fold: true
#| output: false

# Instances where there is an intensity value but phenophase status is not yes?
status <- status %>%
  mutate(intensity_NA = ifelse(is.na(intensity), 1, 0),
         intensity_NotYes = ifelse(intensity_NA == 0 & phenophase_status != 1, 1, 0))
int_no <- filter(status, intensity_NotYes == 1)
  # No instances in 2025, one in 2024 (American beautyberry) and 2 in 2023 (trumpet honeysuckle)

# Are people reporting the number of flowers instead of inflorescences?
# Highest two intensity values for each intensity category worth investigating
ic_subset <- ic_subset %>%
  group_by(intensity_category_id) %>%
  mutate(intensity_high = ifelse(value %in% tail(sort(value), 2), 1, 0)) %>%
  ungroup() %>%
  mutate(intensity_high = ifelse(intensity_type == "percent", 
                                 NA, intensity_high)) %>%
  data.frame()
status <- status %>%
  left_join(select(ic_subset, intensity_name, intensity_value, intensity_high),
            by = c("intensity_name", "intensity_value"))

# Table with number and proportion of observations in top 2 highest intensity
# categories by species and year
intensity_high <- status %>%
  group_by(common_name, php) %>%
  summarize(n2024 = sum(yr == 2024),
            n2025 = sum(yr == 2025),
            nhigh_2024 = sum(yr == 2024 & intensity_high == 1 & !is.na(intensity_high)),
            nhigh_2025 = sum(yr == 2025 & intensity_high == 1 & !is.na(intensity_high)),
            .groups = "keep") %>% 
  filter(nhigh_2024 + nhigh_2025 != 0) %>%
  mutate(prophigh_2024 = round(nhigh_2024 / n2024, 2), 
         prophigh_2025 = round(nhigh_2025 / n2025, 2)) %>%
  data.frame()

# Tables with the number of observations in each high intensity category by
# species and year
intensitycat_high <- status %>%
  filter(intensity_high == 1) %>%
  group_by(common_name, php, intensity_value) %>%
  summarize(n2024 = sum(yr == 2024),
            n2025 = sum(yr == 2025),
            .groups = "keep") %>%
  data.frame()
```

There were `r nrow(int_no)` instances where an observer did not report "yes" for a particular phenohpase, but did report an intensity value; however `r sum(int_no$yr == 2025)` of these instances occurred in 2025.

To explore whether observers were counting the number of flowers (or fruits) rather than the number of inflorescences, we identified observations in where the reported intensity value was in the highest two categories available for that species.

```{r}
#| label: flowers-high
#| tbl-cap: Observations of flowers with high reported intensity values
#| echo: false

knitr::kable(intensitycat_high %>% filter(php == "flower"),
             col.names = c("Species", "Phenophase", "Intensity category", "No. 2024 observations", "No. 2025                            observations"),
             align = c("l", "c", "r", "c", "c"))
```

```{r}
#| label: fruit-high
#| tbl-cap: Observations of fruits with high reported intensity values
#| echo: false

knitr::kable(intensitycat_high %>% filter(php == "fruit"),
             col.names = c("Species", "Phenophase", "Intensity category", "No. 2024 observations", "No. 2025                            observations"),
             align = c("l", "c", "r", "c", "c"))
```

### Identifying inconsistent phenophase status reports

We wanted to identify when observers provided incompatible status reports for different phenophases. In particular, we identified when observers reported a "no" to flowers but reported a "yes" or "?" to open flowers. Similarly, we identified when observers reported a "no" to fruits but reported a "yes" or "?" to ripe fruits. We also identified when observers reported a "?" to flowers but reported a "yes" to open flowers, and when observers reported a "?" to fruits but reported a "yes" to ripe fruits.

```{r}
#| echo: false
#| code-fold: true

# To look at this, can't have more than one observation of a plant per person
# per day. We've already removed duplicates, but now need to resolve instances 
# where somebody made multiple observations of the same plant on the same date 
# that differed in some way.

  # For now, will keep record with more advanced phenophase or higher 
  # intensity value. Will do this by sorting observations in descending
  # order and keeping only the first
  inddateobsp <- status %>%
    group_by(common_name, individual_id, obsdate, person_id, php) %>%
    summarize(n_obs = n(),
              .groups = "keep") %>%
    data.frame()
  inddateobsp$obsnum <- 1:nrow(inddateobsp)
  
  status <- status %>%
    arrange(person_id, individual_id, obsdate, php, 
            desc(phenophase_status), desc(intensity)) %>%
    left_join(select(inddateobsp, -c(n_obs, common_name)), 
              by = c("person_id", "individual_id", 
                     "obsdate", "php")) %>%
    # Create "dups" column, where dups > 1 indicates that the observation can be
    # removed since there's another observation that same day with more advanced
    # phenology or higher intensity/abundance.
    mutate(dups = sequence(rle(as.character(obsnum))$lengths))
  
  # Remove extra observations and unnecessary columns
  status <- status %>%
    filter(dups == 1) %>%
    select(-c(obsnum, dups)) %>%
    arrange(common_name, obsdate, person_id, php)

# To identify inconsistent status values, will need to put flower/fruit data 
# into wide form (all data for a plant visit in the same row). Removing
# unknown status observations first (<0.5% of fruit/flower observations).
statusw <- status %>%
  filter(php != "leaves") %>%
  filter(phenophase_status != -1) %>%
  select(person_id, partner_group, site_id, state, common_name, individual_id,
         yr, obsdate, php, phenophase_status, intensity) %>%
  rename(status = phenophase_status) %>%
  pivot_wider(names_from = php,
              names_glue = "{php}_{.value}",
              values_from = c(status, intensity)) %>%
  data.frame()

# Identify phenophase status inconsistencies
# NOTE: changing NAs to 999 in order to make this code simpler
statusw <- statusw %>%
  mutate(across(contains("status"), ~replace_na(., 999))) %>%
  # Problem: flower = 0, open = NA or 1
  mutate(flower0_openNot0 = ifelse(flower_status == 0 & open.flower_status != 0, 
                                   1, 0)) %>%
  # Problem: flower = NA, open = 1
  mutate(flowerNA_open1 = ifelse(flower_status == 999 & open.flower_status == 1,
                                 1, 0)) %>%
  # Problem: fruit = 0, ripe = NA or 1
  mutate(fruit0_ripeNot0 = ifelse(fruit_status == 0 & ripe.fruit_status != 0, 
                                   1, 0)) %>%
  # Problem: fruit = NA, ripe = 1
  mutate(fruitNA_ripe1 = ifelse(fruit_status == 999 & ripe.fruit_status == 1,
                                1, 0))

# Table summarizing problems with flower/open flower status
flower_probs <- statusw %>%
  group_by(common_name, yr) %>%
  summarize(n = n(),
            n_flower0 = sum(flower_status == 0),
            n_flower1 = sum(flower_status == 1),
            n_flowerNA = sum(flower_status == 999),
            n_open0 = sum(open.flower_status == 0),
            n_open1 = sum(open.flower_status == 1),
            n_openNA = sum(open.flower_status == 999),
            n_flower0_openNot0 = sum(flower0_openNot0 == 1),
            n_flowerNA_open1 = sum(flowerNA_open1 == 1),
            .groups = "keep") %>%
  filter(n_flower0_openNot0 + n_flowerNA_open1 > 0) %>%
  data.frame()

# Table summarizing problems with fruit/ripe fruit status
fruit_probs <- statusw %>%
  group_by(common_name, yr) %>%
  summarize(n = n(),
            n_fruit0 = sum(fruit_status == 0),
            n_fruit1 = sum(fruit_status == 1),
            n_fruitNA = sum(fruit_status == 999),
            n_ripe0 = sum(ripe.fruit_status == 0),
            n_ripe1 = sum(ripe.fruit_status == 1),
            n_ripeNA = sum(ripe.fruit_status == 999),
            n_fruit0_ripeNot0 = sum(fruit0_ripeNot0 == 1),
            n_fruitNA_ripe1 = sum(fruitNA_ripe1 == 1),
            .groups = "keep") %>%
  filter(n_fruit0_ripeNot0 + n_fruitNA_ripe1 > 0) %>%
  data.frame()
```

```{r}
#| label: flower-statusprobs
#| tbl-cap: Inconsistent reports of flowering phenophase statuses
#| echo: false

flower_probs_short <- flower_probs %>%
  select(common_name, yr, n, n_flower0_openNot0, n_flowerNA_open1)

knitr::kable(flower_probs_short,
             col.names = c("Species", "Year", "No. observations", "Flowers: no; Open flowers: yes/?",
                           "Flowers: ?; Open flowers: yes"),
             align = c("l", "c", "c", "c", "c"))
```

```{r}
#| label: fruit-statusprobs
#| tbl-cap: Inconsistent reports of fruiting phenophase statuses
#| echo: false

fruit_probs_short <- fruit_probs %>%
  select(common_name, yr, n, n_fruit0_ripeNot0, n_fruitNA_ripe1)

knitr::kable(fruit_probs_short,
             col.names = c("Species", "Year", "No. observations", "Fruit: no; Ripe fruit: yes/?",
                           "Fruit: ?; Ripe fruit: yes"),
             align = c("l", "c", "c", "c", "c"))
```

### Observation frequency: Reporting a "no" prior to the first "yes"

Working on this.... Thinking I'll need to calculate individual phenometrics from status data (unless we're sure of appropriate period, calendar or water year).

### Summary of data collected

Map (for 2025, or other years too?)

Species table (number of plants, observations by year) – maybe split out by state?

Number of observers (by year, state) – though note that totals may include people not actively/knowingly participating in TTR
